#!/usr/bin/env ruby
#
# Yet another parallel ssh wrapper
#

require 'optparse'

$LOAD_PATH.unshift File.join(File.dirname(__FILE__), '..', 'lib')
require 'net/sshr'
require 'net/sshr/formatter'

$stdout.sync = true

options = {}

# Parse options
op = OptionParser.new
op.banner = "Usage: sshr [options] <host1> [<host2> ...] <cmd>"
op.on('-?', '-h', '--help') do
  puts op
  exit
end
op.on('-l', '--long', "Report long/full command output") do
  options[:fmt] = 'long'
end
op.on('-s', '--short', "Report short command output") do
  options[:fmt] = 'short'
end
op.on('-m', '--merge', "Report merged command output") do
  options[:fmt] = 'merge'
end
op.on('-f', '--fmt', '--format', String, "Formatter to use for reporting") do |val|
  options[:fmt] = val
end

begin
  args = op.parse(ARGV)
rescue => e
  puts "Error: " << e
  puts op
  exit
end
if args.length < 2:
  puts op
  exit
end

cmd = args.pop
#puts "hosts: #{args.join(' ')}"
#puts "cmd:   #{cmd}"

trap("INT") { puts; exit }

sshr = Net::SSHR.new({ :hosts => args })
fmt = Net::SSHR::Formatter.new(options)
sshr.exec(cmd) do |res|
  fmt.render(res)
end

